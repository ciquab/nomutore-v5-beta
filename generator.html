<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<title>NOMUTORE テストデータ生成（constants同期版）</title>
<style>
body { font-family: sans-serif; padding:20px; background:#f5f5f5;}
.section { background:white; padding:15px; margin-bottom:15px; border-radius:8px;}
label { display:block; margin-top:8px;}
input, select { width:100%; padding:6px; margin-top:3px;}
button { margin-top:10px; padding:10px; }
textarea { width:100%; height:250px; margin-top:10px; }
</style>
</head>
<body>

<h1>NOMUTORE テストデータ生成（constants同期）</h1>

<div class="section">
<h2>基本設定</h2>

<label>生成ログ数
<input type="number" id="logCount" value="200">
</label>

<label>開始日
<input type="date" id="startDate">
</label>

<label>終了日
<input type="date" id="endDate">
</label>

</div>

<div class="section">
<h2>分布設定</h2>

<label>スコア傾向
<select id="scoreBias">
<option value="normal">通常</option>
<option value="high">高評価偏重</option>
<option value="low">低評価偏重</option>
</select>
</label>

<label>休肝日率（0〜1）
<input type="number" step="0.1" id="dryRate" value="0.3">
</label>

<label>体調記録生成
<select id="generateCondition">
<option value="yes">生成する</option>
<option value="no">生成しない</option>
</select>
</label>

<label>運動ログ生成
<select id="generateExercise">
<option value="yes">生成する</option>
<option value="no">生成しない</option>
</select>
</label>

</div>

<button id="generateBtn">生成</button>
<button id="downloadBtn">JSONダウンロード</button>
<button id="copyBtn">コピー</button>

<textarea id="output"></textarea>

<script type="module">

import { STYLE_SPECS, CHECK_SCHEMA } from './constants.js';

const STYLE_KEYS = Object.keys(STYLE_SPECS);
let generatedData = null;

// ===== ブルワリー生成ロジック =====

const BREWERY_BRANDS = {
  "箕面ビール": ["ピルスナー", "スタウト", "ヴァイツェン"],
  "志賀高原ビール": ["IPA", "ポーター", "ペールエール"],
  "West Coast Brewing": ["Full Hop Alchemist", "Starwatcher"],
  "Stone Brewing": ["Stone IPA", "Arrogant Bastard"],
  "BrewDog": ["Punk IPA", "Elvis Juice"]
};

const WORD_A = ["Hazy", "Dark", "Golden", "Wild", "Lazy", "Cosmic"];
const WORD_B = ["Fox", "Hop", "River", "Cloud", "Wave", "Sun"];
const WORD_C = ["Brewing", "Craft", "Works", "Collective"];

function randomFrom(arr){
  return arr[Math.floor(Math.random()*arr.length)];
}

function generateRandomBrewery(){
  return `${randomFrom(WORD_B)} ${randomFrom(WORD_C)}`;
}

function generateRandomBrand(){
  return `${randomFrom(WORD_A)} ${randomFrom(WORD_B)}`;
}

function generateBreweryAndBrand(){

  const usePreset = Math.random() < 0.7;

  if(usePreset){
    const breweryKeys = Object.keys(BREWERY_BRANDS);
    const brewery = randomFrom(breweryKeys);
    const brand = randomFrom(BREWERY_BRANDS[brewery]);
    return { brewery, brand };
  } else {
    return {
      brewery: generateRandomBrewery(),
      brand: generateRandomBrand()
    };
  }
}  

function randomBool(rate=0.5){
  return Math.random() < rate;
}

function randomDate(start, end){
  return new Date(start.getTime() + Math.random() * (end.getTime() - start.getTime()));
}

function randomWeight(base=68){
  const fluctuation = (Math.random() * 4 - 2); // ±2kg
  return parseFloat((base + fluctuation).toFixed(1));
}

function generateExercise(timestamp, id){
  return {
    timestamp,
    type: "exercise",
    name: "Walking",
    kcal: -120,
    duration: 30,
    memo: "",
    id
  };
}

function generateCheck(timestamp, id, dryRate, hasLog){

  const isDry = hasLog ? false : randomBool(dryRate);

  const check = {
    timestamp,
    isDryDay: isDry,
    weight: randomWeight(),
    isSaved: true,
    id
  };

  CHECK_SCHEMA.forEach(item=>{
    check[item.id] = randomBool(0.5);
  });

  return check;
}

function generateArchive(monthKey, logs, checks, exercises){
  return {
    month: monthKey,
    logs,
    checks,
    exercises
  };
}

function generateRating(bias){
  const r = Math.random();

  if(bias === "high"){
    return Math.floor(3 + r * 3); // 3〜5
  }
  if(bias === "low"){
    return Math.floor(r * 3); // 0〜2
  }
  return Math.floor(r * 6); // 0〜5
}
  
document.getElementById("generateBtn").addEventListener("click", () => {

  const logCount = parseInt(document.getElementById("logCount").value);
  const startDate = new Date(document.getElementById("startDate").value);
  const endDate = new Date(document.getElementById("endDate").value);
  const dryRate = parseFloat(document.getElementById("dryRate").value);
  const scoreBias = document.getElementById("scoreBias").value;
  const generateCondition = document.getElementById("generateCondition").value;
  const generateExerciseOption = document.getElementById("generateExercise").value;

  const logs = [];
  const checks = [];
  const exercises = [];
  const archivesMap = {};

  let idCounter = 1;

  for(let i=0;i<logCount;i++){

    const date = randomDate(startDate, endDate);
    const timestamp = date.getTime();

    const style = STYLE_KEYS[Math.floor(Math.random()*STYLE_KEYS.length)];
    const spec = STYLE_SPECS[style];
    const { brewery, brand } = generateBreweryAndBrand();

    const log = {
      timestamp,
      type: "beer",
      name: style,
      kcal: -150,
      style,
      size: "350",
      count: 1,
      abv: spec.abv,
      brewery,
      brand,
      rating: generateRating(scoreBias),
      memo: "",
      isCustom: false,
      customType: null,
      rawAmount: null,
      id: idCounter++
    };

    logs.push(log);

    let check = null;

    if(generateCondition === "yes"){
      check = generateCheck(timestamp, idCounter++, dryRate, true);
      checks.push(check);
    }

    if(generateExerciseOption === "yes" && randomBool(0.4)){
      const ex = generateExercise(timestamp, idCounter++);
      exercises.push(ex);
    }

    const monthKey = new Date(timestamp).toISOString().slice(0,7);

    if(!archivesMap[monthKey]){
      archivesMap[monthKey] = {
        logs: [],
        checks: [],
        exercises: []
      };
    }

    archivesMap[monthKey].logs.push(log);
    if(check){
      archivesMap[monthKey].checks.push(check);
    }
  }

  exercises.forEach(ex=>{
    const monthKey = new Date(ex.timestamp).toISOString().slice(0,7);
    if(archivesMap[monthKey]){
      archivesMap[monthKey].exercises.push(ex);
    }
  });

  const archives = Object.keys(archivesMap).map(month =>
    generateArchive(
      month,
      archivesMap[month].logs,
      archivesMap[month].checks,
      archivesMap[month].exercises
    )
  );

  generatedData = {
    version: 4,
    exportedAt: Date.now(),
    data: {
      logs,
      checks,
      exercises,
      archives
    },
    settings: {},
    device: navigator.userAgent
  };

  document.getElementById("output").value =
    JSON.stringify(generatedData, null, 2);
});

document.getElementById("downloadBtn").addEventListener("click", () => {
if(!generatedData) return alert("先に生成してください");

const blob = new Blob([JSON.stringify(generatedData,null,2)],{
type:"application/json"
});
const url = URL.createObjectURL(blob);
const a = document.createElement("a");
a.href = url;
a.download = "nomutore_test_backup.json";
a.click();
});

document.getElementById("copyBtn").addEventListener("click", () => {
const textarea = document.getElementById("output");
textarea.select();
document.execCommand("copy");
alert("コピーしました");
});

</script>
</body>
</html>
